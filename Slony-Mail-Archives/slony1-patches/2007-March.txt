From mailings at oopsware.de  Tue Mar 13 04:36:18 2007
From: mailings at oopsware.de (Bernd Helmle)
Date: Tue Mar 13 04:36:47 2007
Subject: [Slony1-patches] Bug in slonik_execute_script.pl
Message-ID: <219F5272A93D528C28FAFA9F@imhotep.credativ.de>

Folks,

please find attached a very marginal patch which fixes 
slonik_execute_script.pl in tools/altperl. It repairs usage of 
SQL-Scriptfiles, the specified filename isn't passed correctly to the 
EXECUTE SCRIPT command.

I've already posted this to -general, but got no reply on this topic, so 
sorry for reposting this again, if this issue is already adressed.

-- 
  Thanks

                    Bernd
-------------- next part --------------
A non-text attachment was scrubbed...
Name: slonik_execute_script.patch
Type: text/x-diff
Size: 295 bytes
Desc: not available
Url : http://lists.slony.info/pipermail/slony1-patches/attachments/20070313/2026cbcf/slonik_execute_script.bin
From cbbrowne at ca.afilias.info  Tue Mar 13 08:36:23 2007
From: cbbrowne at ca.afilias.info (Christopher Browne)
Date: Tue Mar 13 08:36:28 2007
Subject: [Slony1-patches] Bug in slonik_execute_script.pl
In-Reply-To: <219F5272A93D528C28FAFA9F@imhotep.credativ.de>
References: <219F5272A93D528C28FAFA9F@imhotep.credativ.de>
Message-ID: <45F6C4F7.9010600@ca.afilias.info>

Bernd Helmle wrote:
> Folks,
>
> please find attached a very marginal patch which fixes
> slonik_execute_script.pl in tools/altperl. It repairs usage of
> SQL-Scriptfiles, the specified filename isn't passed correctly to the
> EXECUTE SCRIPT command.
>
> I've already posted this to -general, but got no reply on this topic,
> so sorry for reposting this again, if this issue is already adressed.
I just applied it to the 1.1, 1.2, and HEAD branches.  Thanks for
bringing it up again...
From ssinger_pg at sympatico.ca  Fri Mar 16 19:06:17 2007
From: ssinger_pg at sympatico.ca (Steve Singer)
Date: Mon Mar 19 11:37:50 2007
Subject: [Slony1-patches] EXECUTE script, LOCK TABLES patch 
Message-ID: <Pine.LNX.4.62.0703162157080.3246@mini.atlantida.localdomain>


I had sent this patch out a few months ago and got no response.  Now that we 
have a patches list I thought I'd resend it in-case it got lost.

The goal of the patch is to allow DBA's to explcitly control what tables get 
locked/altered during an EXECUTE script.  If your doing an ALTER table to 
add a column to some table that is in the edges of your schema you might not
really need to lock all tables and take an outage.

The patch is meant to be applied against HEAD.

The idea is that you can specify something like

EXECUTE SCRIPT(set id=1, filename='new_column.sql',
 	event node=1, lock tables = ('public.test1','public.address')
 	);

The ddl_updates_tbl_locks.sql should be added to tests/testddl

The diff file should be applied against CVS HEAD.

Let me know if there are any concerns.


Steve Singer
-------------- next part --------------
ALTER TABLE table5 DROP COLUMN a;
ALTER TABLE table1 ADD COLUMN xy int4;
UPDATE table1 SET xy=1;
-------------- next part --------------
? tests/testddl/ddl_updates_tbl_locks.sql
Index: doc/adminguide/slonik_ref.sgml
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/doc/adminguide/slonik_ref.sgml,v
retrieving revision 1.65
diff -c -r1.65 slonik_ref.sgml
*** doc/adminguide/slonik_ref.sgml	31 Oct 2006 22:09:39 -0000	1.65
--- doc/adminguide/slonik_ref.sgml	18 Dec 2006 04:27:50 -0000
***************
*** 2548,2553 ****
--- 2548,2563 ----
  	subscribed to the set.</para></listitem>
        
       </varlistentry>
+      <varlistentry><term><literal>LOCK TABLES = ('fully.qualified_table1',
+      'fully.qualified_table2','fully_qualified.table3')
+      </literal</term>
+      <listitem><para>(Optional) This option tells Slony to only obtain locks on the
+      tables specified.  It is important that any tables that are referenced in
+      the script being executed be listed here or that this option not be specified
+      which will result in a lock being obtained on all tables.
+      </para>
+      </listitem>
+      </varlistentry>
      </variablelist>
      
      <para> See also the warnings in &rddlchanges;.</para>
***************
*** 2556,2573 ****
      it can get stuck behind other database activity.</para>
       
      <para> At the start of this event, all replicated tables are
!     unlocked via the function
      <function>alterTableRestore(tab_id)</function>.  After the SQL
      script has run, they are returned to <quote>replicating
      state</quote> using
      <function>alterTableForReplication(tab_id)</function>.  This means
!     that all of these tables are locked by this &lslon process for the
      duration of the SQL script execution.</para>
  
      <para> If a table's columns are modified, it is very important
      that the triggers be regenerated, otherwise they may be
      inappropriate for the new form of the table schema.</para>
  
      <para> Note that if you need to make reference to the cluster
      name, you can use the token <command>@CLUSTERNAME@</command>; if
      you need to make reference to the &slony1; namespace, you can use
--- 2566,2590 ----
      it can get stuck behind other database activity.</para>
       
      <para> At the start of this event, all replicated tables are
!     locked and replication is stopped via the function
      <function>alterTableRestore(tab_id)</function>.  After the SQL
      script has run, they are returned to <quote>replicating
      state</quote> using
      <function>alterTableForReplication(tab_id)</function>.  This means
!     that all of these tables are locked by the slonik  process(on the event node) or
!     by the slon process(for other nodes) for the
      duration of the SQL script execution.</para>
  
      <para> If a table's columns are modified, it is very important
      that the triggers be regenerated, otherwise they may be
      inappropriate for the new form of the table schema.</para>
  
+     <para> The LOCK TABLES option can be used to tell Slony to only 
+     lock the tables and suspend replication on the tables indicated.
+     If this option is not specified all replicated tables will be locked
+     during the execution of the script.
+     </para>
+ 
      <para> Note that if you need to make reference to the cluster
      name, you can use the token <command>@CLUSTERNAME@</command>; if
      you need to make reference to the &slony1; namespace, you can use
***************
*** 2587,2595 ****
     </refsect1>
     <refsect1> <title> Locking Behaviour </title>
  
!     <para> Each replicated table receives an exclusive lock, on the
!     origin node, in order to remove the replication triggers; after
!     the DDL script completes, those locks will be cleared. </para>
  
      <para> After the DDL script has run on the origin node, it will
      then run on subscriber nodes, where replicated tables will be
--- 2604,2645 ----
     </refsect1>
     <refsect1> <title> Locking Behaviour </title>
  
!     <para> If the LOCK TABLES options is not specified then each replicated table
!      receives an exclusive lock on the
!     origin node in order to remove the replication triggers. Every other replicated
!     table will have its application and constraint triggers re-enablled on the slave
!     databases for the duration of the EXECUTE SCRIPT. After
!     the DDL script completes the locks will be cleared and triggers will be reverted.
!     All non-Slony database
!     activity on replicated tables should be stopped to prevent the risk of deadlock.</para>
!     
!     <para> If the LOCK TABLES option is specified then only the the tables
!     listed will have the replication triggers removed from them on the origin or other triggers
!     enabled on the slave. This will require
!      obtaining an exclusive lock on each listed table for the duration of the EXECUTE script.
!     After the DDL script completes, those locks will be cleared. 
!     This allows the DBA to control which tables will be locked during the EXECUTE SCRIPT
!     </para>
! 
!     <para>
!     Any tables that are referenced in the DDL script need to be locked.  The following guidelines
!     are useful:    
!     </para>
!     <itemizedlist>
!     <listitem><para>Any tables referenced by an ALTER table must be locked</para></listitem>
!     <listitem><para>If adding a foreign key both the table the key is being added to and
!     the table the foreign key references must be locked</para></listitem>
!     <listitem><para>Any tables that are the target of INSERT or UPDATE statements must be locked
!     </para></listitem>
!     <listitem><para>Any tables that are being queried must be locked</para></listitem>
!     <listitem><para>If a table is being dropped it should be removed from all replication sets
!     before the DDL script is run and thus does not need to be locked</para></listitem>
!     <listitem><para>If in doubt don't use the LOCK TABLES option and allow Slony to lock everything
!     </para></listitem>
! 
!     </itemizedlist>
! 
!    
  
      <para> After the DDL script has run on the origin node, it will
      then run on subscriber nodes, where replicated tables will be
Index: src/backend/slony1_funcs.sql
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/src/backend/slony1_funcs.sql,v
retrieving revision 1.103
diff -c -r1.103 slony1_funcs.sql
*** src/backend/slony1_funcs.sql	15 Dec 2006 05:34:18 -0000	1.103
--- src/backend/slony1_funcs.sql	18 Dec 2006 04:27:53 -0000
***************
*** 3664,3669 ****
--- 3664,3671 ----
  Processes DROP_TRIGGER event to make sure that trigger trig_tgname on
  replicated table trig_tabid IS disabled.';
  
+ 
+ 
  -- ----------------------------------------------------------------------
  -- FUNCTION ddlScript_prepare (set_id, only_on_node)
  --
***************
*** 3671,3680 ****
--- 3673,3700 ----
  -- ----------------------------------------------------------------------
  create or replace function @NAMESPACE@.ddlScript_prepare (int4, int4)
  returns integer
+ as ' 
+ begin
+   return @NAMESPACE@.ddlScirpt_prepare($1,$2,null);
+ end;
+ ' language plpgsql;
+ 
+ 
+ comment on function @NAMESPACE@.ddlScript_prepare (int4, int4) is 
+ 'Prepare for DDL script execution on origin. All replicated tables will be prepared';
+ 
+ -- ----------------------------------------------------------------------
+ -- FUNCTION ddlScript_prepare (set_id, only_on_node,p_lock_tab_ids)
+ --
+ --	Generate the DDL_SCRIPT event
+ -- ----------------------------------------------------------------------
+ create or replace function @NAMESPACE@.ddlScript_prepare (int4, int4,int4[])
+ returns integer
  as '
  declare
  	p_set_id			alias for $1;
  	p_only_on_node		alias for $2;
+ 	p_lock_tab_ids          alias for $3;
  	v_set_origin		int4;
  begin
  	-- ----
***************
*** 3697,3714 ****
  				p_set_id;
  	end if;
  
  	-- ----
  	-- Create a SYNC event, run the script and generate the DDL_SCRIPT event
  	-- ----
-     perform @NAMESPACE@.alterTableRestore(tab_id) from @NAMESPACE@.sl_table where tab_set in (select set_id from @NAMESPACE@.sl_set where set_origin = @NAMESPACE@.getLocalNodeId(''_@CLUSTERNAME@''));
- 
  	perform @NAMESPACE@.createEvent(''_@CLUSTERNAME@'', ''SYNC'', NULL);
  	return 1;
  end;
  ' language plpgsql;
  
! comment on function @NAMESPACE@.ddlScript_prepare (int4, int4) is 
! 'Prepare for DDL script execution on origin';
  
  -- 	perform @NAMESPACE@.ddlScript_int(p_set_id, p_script, p_only_on_node);
  
--- 3717,3747 ----
  				p_set_id;
  	end if;
  
+ 
+ 	
+ 	if p_lock_tab_ids is not null then
+ 		
+ 	      perform @NAMESPACE@.alterTableRestore(tab_id) from @NAMESPACE@.sl_table where tab_set in (select set_id from @NAMESPACE@.sl_set where set_origin = @NAMESPACE@.getLocalNodeId(''_@CLUSTERNAME@''))
+ 	and tab_id =any (p_lock_tab_ids)
+ 	;
+ 	else
+ 
+ 	    perform @NAMESPACE@.alterTableRestore(tab_id) from @NAMESPACE@.sl_table where tab_set in (select set_id from @NAMESPACE@.sl_set where set_origin = @NAMESPACE@.getLocalNodeId(''_@CLUSTERNAME@''));
+ 	end if;
+ 
  	-- ----
  	-- Create a SYNC event, run the script and generate the DDL_SCRIPT event
  	-- ----
  	perform @NAMESPACE@.createEvent(''_@CLUSTERNAME@'', ''SYNC'', NULL);
  	return 1;
  end;
  ' language plpgsql;
  
! 
! comment on function @NAMESPACE@.ddlScript_prepare (int4, int4,int4[]) is 
! 'Prepare for DDL script execution on origin. All replicated tables will be prepared if
!  lock_tab_ids is null otherwise just the specified tables will be prepared. ';
! 
  
  -- 	perform @NAMESPACE@.ddlScript_int(p_set_id, p_script, p_only_on_node);
  
***************
*** 3720,3756 ****
  create or replace function @NAMESPACE@.ddlScript_complete (int4, text, int4)
  returns integer
  as '
  declare
  	p_set_id			alias for $1;
  	p_script			alias for $2;
  	p_only_on_node		alias for $3;
  	v_set_origin		int4;
  begin
  	perform @NAMESPACE@.updateRelname(p_set_id, p_only_on_node);
!     perform @NAMESPACE@.alterTableForReplication(tab_id) from @NAMESPACE@.sl_table where tab_set in (select set_id from @NAMESPACE@.sl_set where set_origin = @NAMESPACE@.getLocalNodeId(''_@CLUSTERNAME@''));
  	return  @NAMESPACE@.createEvent(''_@CLUSTERNAME@'', ''DDL_SCRIPT'', 
! 			p_set_id, p_script, p_only_on_node);
  end;
  ' language plpgsql;
  
  comment on function @NAMESPACE@.ddlScript_complete(int4, text, int4) is
! 'ddlScript_complete(set_id, script, only_on_node)
  
  After script has run on origin, this fixes up relnames, restores
  triggers, and generates a DDL_SCRIPT event to request it to be run on
! replicated slaves.';
  
  -- ----------------------------------------------------------------------
! -- FUNCTION ddlScript_prepare_int (set_id, only_on_node)
  --
  --	Prepare for the DDL_SCRIPT event
  -- ----------------------------------------------------------------------
! create or replace function @NAMESPACE@.ddlScript_prepare_int (int4, int4)
  returns int4
  as '
  declare
  	p_set_id			alias for $1;
  	p_only_on_node		alias for $2;
  	v_set_origin		int4;
  	v_no_id				int4;
  	v_row				record;
--- 3753,3813 ----
  create or replace function @NAMESPACE@.ddlScript_complete (int4, text, int4)
  returns integer
  as '
+ begin
+ 	return @NAMESPACE@.ddlScript_complete($1,$2,$3,null);
+ end;
+ ' language plpgsql;
+ 
+ 
+ -- 	perform @NAMESPACE@.ddlScript_int(p_set_id, p_script, p_only_on_node);
+ 
+ -- ----------------------------------------------------------------------
+ -- FUNCTION ddlScript_complete (set_id, script, only_on_node)
+ --
+ --	Generate the DDL_SCRIPT event
+ -- ----------------------------------------------------------------------
+ create or replace function @NAMESPACE@.ddlScript_complete (int4, text, int4,int4[])
+ returns integer
+ as '
  declare
  	p_set_id			alias for $1;
  	p_script			alias for $2;
  	p_only_on_node		alias for $3;
+ 	p_lock_tab_ids          alias for $4;
  	v_set_origin		int4;
  begin
  	perform @NAMESPACE@.updateRelname(p_set_id, p_only_on_node);
! 
! 	if p_lock_tab_ids is not null then
! 		perform @NAMESPACE@.alterTableForReplication(tab_id) from @NAMESPACE@.sl_table where tab_set in (select set_id from @NAMESPACE@.sl_set where set_origin = @NAMESPACE@.getLocalNodeId(''_@CLUSTERNAME@'')) and tab_id = any (p_lock_tab_ids) ;
! 	else
!     		perform @NAMESPACE@.alterTableForReplication(tab_id) from @NAMESPACE@.sl_table where tab_set in (select set_id from @NAMESPACE@.sl_set where set_origin = @NAMESPACE@.getLocalNodeId(''_@CLUSTERNAME@''));
! 	end if;
! 
  	return  @NAMESPACE@.createEvent(''_@CLUSTERNAME@'', ''DDL_SCRIPT'', 
! 			p_set_id, p_script, p_only_on_node,array_to_string(p_lock_tab_ids,'',''));
  end;
  ' language plpgsql;
  
  comment on function @NAMESPACE@.ddlScript_complete(int4, text, int4) is
! 'ddlScript_complete(set_id, script, only_on_node,p_lock_tab_ids)
  
  After script has run on origin, this fixes up relnames, restores
  triggers, and generates a DDL_SCRIPT event to request it to be run on
! replicated slaves. ';
  
  -- ----------------------------------------------------------------------
! -- FUNCTION ddlScript_prepare_int (set_id, only_on_node,lock_table_ids)
  --
  --	Prepare for the DDL_SCRIPT event
  -- ----------------------------------------------------------------------
! create or replace function @NAMESPACE@.ddlScript_prepare_int (int4, int4,int4[])
  returns int4
  as '
  declare
  	p_set_id			alias for $1;
  	p_only_on_node		alias for $2;
+ 	p_lock_table_ids        alias for $3;
  	v_set_origin		int4;
  	v_no_id				int4;
  	v_row				record;
***************
*** 3788,3797 ****
  		return 0;
  	end if;
  
  	-- ----
  	-- Restore all original triggers and rules of all sets
  	-- ----
! 	for v_row in select * from @NAMESPACE@.sl_table
  	loop
  		perform @NAMESPACE@.alterTableRestore(v_row.tab_id);
  	end loop;
--- 3845,3856 ----
  		return 0;
  	end if;
  
+ 
  	-- ----
  	-- Restore all original triggers and rules of all sets
  	-- ----
! 	for v_row in select * from @NAMESPACE@.sl_table	
! 	    where tab_id =any (p_lock_table_ids) or p_lock_table_ids is null
  	loop
  		perform @NAMESPACE@.alterTableRestore(v_row.tab_id);
  	end loop;
***************
*** 3799,3805 ****
  end;
  ' language plpgsql;
  
! comment on function @NAMESPACE@.ddlScript_prepare_int (int4, int4) is
  'ddlScript_prepare_int (set_id, only_on_node)
  
  Do preparatory work for a DDL script, restoring 
--- 3858,3864 ----
  end;
  ' language plpgsql;
  
! comment on function @NAMESPACE@.ddlScript_prepare_int (int4, int4,int4[]) is
  'ddlScript_prepare_int (set_id, only_on_node)
  
  Do preparatory work for a DDL script, restoring 
***************
*** 3807,3828 ****
  
  
  -- ----------------------------------------------------------------------
! -- FUNCTION ddlScript_complete_int (set_id, only_on_node)
  --
  --	Complete the DDL_SCRIPT event
  -- ----------------------------------------------------------------------
! create or replace function @NAMESPACE@.ddlScript_complete_int (int4, int4)
  returns int4
  as '
  declare
  	p_set_id			alias for $1;
  	p_only_on_node		alias for $2;
  	v_row				record;
  begin
  	-- ----
  	-- Put all tables back into replicated mode
  	-- ----
  	for v_row in select * from @NAMESPACE@.sl_table
  	loop
  		perform @NAMESPACE@.alterTableForReplication(v_row.tab_id);
  	end loop;
--- 3866,3889 ----
  
  
  -- ----------------------------------------------------------------------
! -- FUNCTION ddlScript_complete_int (set_id, only_on_node,p_lock_table_ids)
  --
  --	Complete the DDL_SCRIPT event
  -- ----------------------------------------------------------------------
! create or replace function @NAMESPACE@.ddlScript_complete_int (int4, int4,int4[])
  returns int4
  as '
  declare
  	p_set_id			alias for $1;
  	p_only_on_node		alias for $2;
+ 	p_lock_table_ids        alias for $3;
  	v_row				record;
  begin
  	-- ----
  	-- Put all tables back into replicated mode
  	-- ----
  	for v_row in select * from @NAMESPACE@.sl_table
+ 	       where tab_id =any (p_lock_table_ids) or p_lock_table_ids is null
  	loop
  		perform @NAMESPACE@.alterTableForReplication(v_row.tab_id);
  	end loop;
***************
*** 3830,3836 ****
  	return p_set_id;
  end;
  ' language plpgsql;
! comment on function @NAMESPACE@.ddlScript_complete_int(int4, int4) is
  'ddlScript_complete_int(set_id, script, only_on_node)
  
  Complete processing the DDL_SCRIPT event.  This puts tables back into
--- 3891,3897 ----
  	return p_set_id;
  end;
  ' language plpgsql;
! comment on function @NAMESPACE@.ddlScript_complete_int(int4, int4,int4[]) is
  'ddlScript_complete_int(set_id, script, only_on_node)
  
  Complete processing the DDL_SCRIPT event.  This puts tables back into
***************
*** 5902,5904 ****
--- 5963,5994 ----
  to specify fields for the passed-in tab_id.  
  
  In PG versions > 7.3, this looks like (field1,field2,...fieldn)';
+ 
+ 
+ 
+ 
+ 
+ -- ----------------------------------------------------------------------
+ -- FUNCTION getTabId(fully_qualifed_name)
+ -- Get the slony table id for the fully qualified name
+ --
+ --	
+ -- ----------------------------------------------------------------------
+ create or replace function @NAMESPACE@.getTabId(text)
+ returns integer
+ as '
+ declare
+     p_fq_name  alias for $1;
+     result integer;
+ begin
+ 
+ 	select into result tab_id from @NAMESPACE@.sl_table where
+ 	tab_nspname || ''.'' || tab_relname = p_fq_name limit 1;
+ 	return result;
+ end;
+ ' language plpgsql;
+ 
+ comment on function @NAMESPACE@.getTabId(text) is
+ 'Returns the slony table_id for the fully qualified (schema.tablename) passed.
+ If no such table exists null is returned.
+ ';
\ No newline at end of file
Index: src/slon/remote_worker.c
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/src/slon/remote_worker.c,v
retrieving revision 1.131
diff -c -r1.131 remote_worker.c
*** src/slon/remote_worker.c	12 Dec 2006 20:13:01 -0000	1.131
--- src/slon/remote_worker.c	18 Dec 2006 04:27:57 -0000
***************
*** 1340,1360 ****
  				char	   *ddl_script = event->ev_data2;
  				int			ddl_only_on_node = (int)strtol(event->ev_data3, NULL, 10);
  				int num_statements = -1, stmtno;
! 
  				PGresult *res;
  				ExecStatusType rstat;
! 
! 
! 				slon_appendquery(&query1,
! 						 "select %s.ddlScript_prepare_int(%d, %d); ",
! 						 rtcfg_namespace,
! 						 ddl_setid, ddl_only_on_node);
! 
! 				if (query_execute(node, local_dbconn, &query1) < 0) {
! 						slon_log(SLON_ERROR, "remoteWorkerThread_%d: DDL preparation failed - set %d - only on node %\n",
! 							 node->no_id, ddl_setid, ddl_only_on_node);
! 						slon_retry();
  				}
  
  				num_statements = scan_for_statements (ddl_script);
  				slon_log(SLON_CONFIG, "remoteWorkerThread_%d: DDL request with %d statements\n",
--- 1340,1371 ----
  				char	   *ddl_script = event->ev_data2;
  				int			ddl_only_on_node = (int)strtol(event->ev_data3, NULL, 10);
  				int num_statements = -1, stmtno;
! 				const char * lock_table_list = event->ev_data4;
! 				
  				PGresult *res;
  				ExecStatusType rstat;
! 				
! 				if(lock_table_list != NULL ) 
! 				{
! 					 slon_appendquery(&query1,
! 									  "select %s.ddlScript_prepare_int(%d,%d, '{%s}'); ",
! 									  rtcfg_namespace,
! 									  ddl_setid, ddl_only_on_node,lock_table_list);
! 				}/*locks*/							
! 				else 
! 				{
! 					 slon_appendquery(&query1,
! 									  "select %s.ddlScript_prepare_int(%d, %d,null); ",
! 									  rtcfg_namespace,
! 									  ddl_setid, ddl_only_on_node);
! 				}
! 				if (query_execute(node, local_dbconn, &query1) < 0)
! 				{
! 				     slon_log(SLON_ERROR, "remoteWorkerThread_%d: DDL preparation failed - set %d - only on node %d\n",
! 							  node->no_id, ddl_setid, ddl_only_on_node);
! 					 slon_retry();
  				}
+ 				
  
  				num_statements = scan_for_statements (ddl_script);
  				slon_log(SLON_CONFIG, "remoteWorkerThread_%d: DDL request with %d statements\n",
***************
*** 1402,1411 ****
  					slon_log (SLON_CONFIG, "DDL success - %s\n", PQresStatus(rstat));
  				}
  	
! 				slon_mkquery(&query1, "select %s.ddlScript_complete_int(%d, %d); ", 
! 					     rtcfg_namespace,
! 					     ddl_setid,
! 					     ddl_only_on_node);
  
  				/* DDL_SCRIPT needs to be turned into a log shipping script */
  				/* Note that the issue about parsing that mandates breaking 
--- 1413,1437 ----
  					slon_log (SLON_CONFIG, "DDL success - %s\n", PQresStatus(rstat));
  				}
  	
! 				
! 				if(lock_table_list != NULL ) 
! 				{
! 				  
! 				     slon_mkquery(&query1, "select %s.ddlScript_complete_int(%d,%d,'{%s}'); ", 
! 						  rtcfg_namespace,
! 						  ddl_setid,
! 						  ddl_only_on_node,lock_table_list);
! 				   
! 				}
! 				else 
! 				{
! 
! 				
! 				     slon_mkquery(&query1, "select %s.ddlScript_complete_int(%d, %d,null); ", 
! 						  rtcfg_namespace,
! 						  ddl_setid,
! 						  ddl_only_on_node);
! 				}
  
  				/* DDL_SCRIPT needs to be turned into a log shipping script */
  				/* Note that the issue about parsing that mandates breaking 
***************
*** 6091,6093 ****
--- 6117,6122 ----
  	}
  	slon_log(SLON_DEBUG3, " compressed actionseq subquery... %s\n", dstring_data(action_subquery));
  }
+ 
+ 
+ 
Index: src/slonik/parser.y
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/src/slonik/parser.y,v
retrieving revision 1.27
diff -c -r1.27 parser.y
*** src/slonik/parser.y	31 Oct 2006 22:09:40 -0000	1.27
--- src/slonik/parser.y	18 Dec 2006 04:27:58 -0000
***************
*** 50,60 ****
  	O_USE_KEY,
  	O_WAIT_CONFIRMED,
  	O_WAIT_ON,
! 
  	END_OF_OPTIONS = -1
  } option_code;
  
  
  /*
   * Common given option list
   */
--- 50,70 ----
  	O_USE_KEY,
  	O_WAIT_CONFIRMED,
  	O_WAIT_ON,
! 	O_LOCK_TABLES,
  	END_OF_OPTIONS = -1
  } option_code;
  
  
+ /**
+  * A structure that stores a list of table names as a linked list.
+  * Table names are stored in fully qualified format.
+  */
+ typedef struct table_list {
+ 	char * name;
+ 	struct table_list * next;
+ } table_list;
+ 
+ 
  /*
   * Common given option list
   */
***************
*** 63,69 ****
  	int			lineno;
  	int32		ival;
  	char	   *str;
! 
  	struct option_list *next;
  } option_list;
  
--- 73,79 ----
  	int			lineno;
  	int32		ival;
  	char	   *str;
! 	table_list * table_list;
  	struct option_list *next;
  } option_list;
  
***************
*** 76,86 ****
  	int			lineno;
  	int			ival;
  	char	   *str;
  } statement_option;
! #define	STMT_OPTION_INT(_code,_dfl)		{_code, -1, _dfl, NULL}
! #define	STMT_OPTION_STR(_code,_dfl)		{_code, -1, -1, _dfl}
! #define	STMT_OPTION_YN(_code,_dfl)		{_code, -1, _dfl, NULL}
! #define STMT_OPTION_END					{END_OF_OPTIONS, -1, -1, NULL}
  
  
  /*
--- 86,100 ----
  	int			lineno;
  	int			ival;
  	char	   *str;
+ 	table_list * table_list;
  } statement_option;
! #define	STMT_OPTION_INT(_code,_dfl)		{_code, -1, _dfl, NULL,NULL}
! #define	STMT_OPTION_STR(_code,_dfl)		{_code, -1, -1, _dfl,NULL}
! #define	STMT_OPTION_YN(_code,_dfl)		{_code, -1, _dfl, NULL,NULL}
! #define STMT_OPTION_TBLLIST(_code,_dfl) {_code, -1,-1,NULL,_dfl}
! #define STMT_OPTION_END					{END_OF_OPTIONS, -1, -1, NULL,NULL}
! 
! 
  
  
  /*
***************
*** 109,114 ****
--- 123,129 ----
  	option_list	*opt_list;
  	SlonikAdmInfo	*adm_info;
  	SlonikStmt	*statement;
+ 	table_list * table_list;
  }
  
  %type <ival>		id
***************
*** 169,175 ****
  %type <opt_list>	option_item_id
  %type <opt_list>	option_item_literal
  %type <opt_list>	option_item_yn
! 
  
  /*
   * Keyword tokens
--- 184,191 ----
  %type <opt_list>	option_item_id
  %type <opt_list>	option_item_literal
  %type <opt_list>	option_item_yn
! %type <table_list>  table_list
! %type <table_list>  table_list_items
  
  /*
   * Keyword tokens
***************
*** 247,253 ****
  %token	K_WAIT
  %token	K_SYNC
  %token	K_SLEEP
! 
  /*
   * Other scanner tokens
   */
--- 263,269 ----
  %token	K_WAIT
  %token	K_SYNC
  %token	K_SLEEP
! %token  K_TABLES
  /*
   * Other scanner tokens
   */
***************
*** 1345,1350 ****
--- 1361,1367 ----
  							STMT_OPTION_STR( O_FILENAME, NULL ),
  							STMT_OPTION_INT( O_EVENT_NODE, 1 ),
  							STMT_OPTION_INT( O_EXECUTE_ONLY_ON, -1 ),
+ 							STMT_OPTION_TBLLIST( O_LOCK_TABLES,NULL),
  							STMT_OPTION_END
  						};
  
***************
*** 1354,1366 ****
  						new->hdr.stmt_type		= STMT_DDL_SCRIPT;
  						new->hdr.stmt_filename	= current_file;
  						new->hdr.stmt_lno		= $1;
! 
  						if (assign_options(opt, $4) == 0)
  						{
  							new->ddl_setid		= opt[0].ival;
  							new->ddl_fname		= opt[1].str;
  							new->ev_origin		= opt[2].ival;
  							new->only_on_node	= opt[3].ival;
  							new->ddl_fd		= NULL;
  						}
  						else
--- 1371,1410 ----
  						new->hdr.stmt_type		= STMT_DDL_SCRIPT;
  						new->hdr.stmt_filename	= current_file;
  						new->hdr.stmt_lno		= $1;
! 						
  						if (assign_options(opt, $4) == 0)
  						{
+ 							table_list * lock_list_ptr;
+ 							int lock_count;
+ 							int table_ind;
  							new->ddl_setid		= opt[0].ival;
  							new->ddl_fname		= opt[1].str;
  							new->ev_origin		= opt[2].ival;
  							new->only_on_node	= opt[3].ival;
+ 							lock_count=0;
+ 							for(lock_list_ptr=opt[4].table_list;
+ 								lock_list_ptr!=NULL;
+ 								lock_list_ptr=lock_list_ptr->next)
+ 							{
+ 								lock_count++;
+ 							}
+ 								
+ 							if(lock_count > 0 ) 
+ 							{
+ 								new->table_locks=malloc(sizeof(char*)*lock_count+1);
+ 								for(lock_list_ptr=opt[4].table_list,table_ind=0;
+ 									lock_list_ptr!=NULL;
+ 									lock_list_ptr=lock_list_ptr->next,table_ind++)
+ 								{
+ 									new->table_locks[table_ind] = lock_list_ptr->name;
+ 									
+ 								}
+ 								new->table_locks[table_ind]=NULL;
+ 							}
+ 							else 
+ 							{
+ 								new->table_locks=NULL;
+ 							}
  							new->ddl_fd		= NULL;
  						}
  						else
***************
*** 1662,1667 ****
--- 1706,1712 ----
  						new->ival	= 1;
  						new->str	= NULL;
  						new->lineno	= yylineno;
+ 						new->table_list=NULL;
  						new->next	= NULL;
  
  						$$ = new;
***************
*** 1685,1690 ****
--- 1730,1736 ----
  						new->ival	= -2;
  						new->str	= NULL;
  						new->lineno	= yylineno;
+ 						new->table_list=NULL;
  						new->next	= NULL;
  
  						$$ = new;
***************
*** 1703,1708 ****
--- 1749,1755 ----
  						new->ival	= -2;
  						new->str	= NULL;
  						new->lineno	= yylineno;
+ 						new->table_list=NULL;
  						new->next	= NULL;
  
  						$$ = new;
***************
*** 1732,1737 ****
--- 1779,1796 ----
  						$3->opt_code	= O_SECONDS;
  						$$ = $3;
  					}
+ 					| K_LOCK K_TABLES '=' table_list
+ 					{
+ 						option_list * new;
+ 
+ 						new = (option_list*) malloc(sizeof(option_list));
+ 						new->ival=-1;
+ 						new->str=NULL;
+ 						new->next=NULL;
+ 						new->table_list=$4;
+ 						new->opt_code	= O_LOCK_TABLES;
+ 						$$=new;
+ 					}
  					;
  
  option_item_id		: id
***************
*** 1742,1747 ****
--- 1801,1807 ----
  						new->ival	= $1;
  						new->str	= NULL;
  						new->lineno	= yylineno;
+ 						new->table_list=NULL;
  						new->next	= NULL;
  
  						$$ = new;
***************
*** 1756,1761 ****
--- 1816,1822 ----
  						new->ival	= -1;
  						new->str	= $1;
  						new->lineno	= yylineno;
+ 						new->table_list=NULL;
  						new->next	= NULL;
  
  						$$ = new;
***************
*** 1770,1775 ****
--- 1831,1837 ----
  						new->ival	= 1;
  						new->str	= NULL;
  						new->lineno	= yylineno;
+ 						new->table_list=NULL;
  						new->next	= NULL;
  
  						$$ = new;
***************
*** 1782,1787 ****
--- 1844,1850 ----
  						new->ival	= 0;
  						new->str	= NULL;
  						new->lineno	= yylineno;
+ 						new->table_list=NULL;
  						new->next	= NULL;
  
  						$$ = new;
***************
*** 1829,1836 ****
  					;
  
  lno					:
! 					{ $$ = yylineno; }
  					;
  
  %%
  
--- 1892,1920 ----
  					;
  
  lno					:
!                     { $$ = yylineno; }
  					;
+ table_list          : '(' table_list_items ')'
+                        {
+ 						   $$=$2;
+ 					   }
+                     ;
+ 
+                       
+ table_list_items          : table_list_items ',' literal 
+                       {
+ 						  $$ = malloc(sizeof(table_list));
+ 						  $$->name=$3;
+ 						  $$->next = $1;
+                       }
+                       | literal
+                       {
+ 						  $$ = malloc(sizeof(table_list));
+ 						  $$->name = $1;
+ 						  $$->next=NULL;
+ 					  }
+                       ;
+ 
  
  %%
  
***************
*** 1876,1881 ****
--- 1960,1966 ----
  		case O_USE_KEY:			return "key";
  		case O_WAIT_CONFIRMED:	return "confirmed";
  		case O_WAIT_ON:			return "wait on";
+ 	    case O_LOCK_TABLES:     return "lock tables";
  		case END_OF_OPTIONS:	return "???";
  	}
  	return "???";
***************
*** 1924,1929 ****
--- 2009,2015 ----
  		s_opt->lineno	= u_opt->lineno;
  		s_opt->ival		= u_opt->ival;
  		s_opt->str		= u_opt->str;
+ 		s_opt->table_list = u_opt->table_list;
  	}
  
  	return errors;
Index: src/slonik/scan.l
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/src/slonik/scan.l,v
retrieving revision 1.26
diff -c -r1.26 scan.l
*** src/slonik/scan.l	31 Oct 2006 22:09:40 -0000	1.26
--- src/slonik/scan.l	18 Dec 2006 04:27:58 -0000
***************
*** 139,145 ****
  update			{ return K_UPDATE;			}
  yes				{ return K_YES;				}
  wait			{ return K_WAIT;			}
! 
  {digit}+		{ return T_NUMBER;			}
  {identifier}	{ return T_IDENT;			}
  
--- 139,145 ----
  update			{ return K_UPDATE;			}
  yes				{ return K_YES;				}
  wait			{ return K_WAIT;			}
! tables          { return K_TABLES;          }
  {digit}+		{ return T_NUMBER;			}
  {identifier}	{ return T_IDENT;			}
  
Index: src/slonik/slonik.c
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/src/slonik/slonik.c,v
retrieving revision 1.71
diff -c -r1.71 slonik.c
*** src/slonik/slonik.c	12 Dec 2006 14:54:48 -0000	1.71
--- src/slonik/slonik.c	18 Dec 2006 04:28:00 -0000
***************
*** 3834,3846 ****
  	char		rex4[256];
  	PGresult *res;
  	ExecStatusType rstat;
  
  #define PARMCOUNT 1  
  
          const char *params[PARMCOUNT];
          int paramlens[PARMCOUNT];
          int paramfmts[PARMCOUNT];
! 
  	adminfo1 = get_active_adminfo((SlonikStmt *) stmt, stmt->ev_origin);
  	if (adminfo1 == NULL)
  		return -1;
--- 3834,3847 ----
  	char		rex4[256];
  	PGresult *res;
  	ExecStatusType rstat;
+ 	SlonDString lock_tab_ids;
  
  #define PARMCOUNT 1  
  
          const char *params[PARMCOUNT];
          int paramlens[PARMCOUNT];
          int paramfmts[PARMCOUNT];
! 	
  	adminfo1 = get_active_adminfo((SlonikStmt *) stmt, stmt->ev_origin);
  	if (adminfo1 == NULL)
  		return -1;
***************
*** 3863,3879 ****
  		dstring_nappend(&script, buf, rc);
  	}
  	dstring_terminate(&script);
- 
  	dstring_init(&query);
  	slon_mkquery(&query,
! 		     "select \"_%s\".ddlScript_prepare(%d, %d); ",
! 		     stmt->hdr.script->clustername,
! 		     stmt->ddl_setid, /* dstring_data(&script),  */ 
! 		     stmt->only_on_node);
! 
  	if (db_exec_evcommand((SlonikStmt *) stmt, adminfo1, &query) < 0)
  	{
  		dstring_free(&query);
  		return -1;
  	}
  
--- 3864,3943 ----
  		dstring_nappend(&script, buf, rc);
  	}
  	dstring_terminate(&script);
  	dstring_init(&query);
+ 	dstring_init(&lock_tab_ids);
+ 		
+ 	if(stmt->table_locks!=NULL) 
+ 	{
+ 		
+ 
+ 		char ** table;
+ 		/**
+ 		 * Only Obtain locks on the specified tables.
+ 		 */
+ 		dstring_append(&lock_tab_ids,"'{");
+ 		for(table=stmt->table_locks;
+ 			*table!=NULL;
+ 			table++)
+ 		{
+ 			int tab_id;
+ 			/**
+ 			 * Get the tab_id for each
+ 			 */
+ 			slon_mkquery(&query,
+ 						 "select \"_%s\".getTabId('%s');",
+ 						 stmt->hdr.script->clustername,*table);
+ 			res = db_exec_select((SlonikStmt*) stmt,adminfo1,&query);
+ 			if(res==NULL) 
+ 			{
+ 				dstring_free(&query);
+ 				dstring_free(&lock_tab_ids);
+ 				return -1;
+ 			}
+ 			if(PQntuples(res)==0 || PQgetisnull(res,0,0) ) 
+ 			{
+ 				printf("%s is not a replicated table\n",*table);
+ 				dstring_free(&query);
+ 				dstring_free(&lock_tab_ids);
+ 				PQclear(res);
+ 				return -1;
+ 			}
+ 			tab_id = atoi(PQgetvalue(res,0,0));
+ 			PQclear(res);
+ 			if(table==stmt->table_locks) 
+ 			{
+ 				sprintf(buf,"%d",tab_id);
+ 				dstring_append(&lock_tab_ids,buf);
+ 			}
+ 			else
+ 			{
+ 				sprintf(buf,",%d",tab_id);
+ 				dstring_append(&lock_tab_ids,buf);
+ 			}
+ 		}
+ 		dstring_append(&lock_tab_ids,"}'");
+ 		
+ 	}
+ 	else {
+ 		dstring_append(&lock_tab_ids,"null");
+ 	}
+ 	dstring_terminate(&lock_tab_ids);
+ 	/**
+ 	 * Lock  replicated tables requested. (If none requested all tables get locked)
+ 	 */
+ 	
+ 	dstring_reset(&query);
  	slon_mkquery(&query,
! 				 "select \"_%s\".ddlScript_prepare(%d, %d,%s); ",
! 				 stmt->hdr.script->clustername,
! 				 stmt->ddl_setid, /* dstring_data(&script),  */ 
! 				 stmt->only_on_node,
! 				 dstring_data(&lock_tab_ids));
! 	
  	if (db_exec_evcommand((SlonikStmt *) stmt, adminfo1, &query) < 0)
  	{
  		dstring_free(&query);
+ 		dstring_free(&lock_tab_ids);
  		return -1;
  	}
  
***************
*** 3923,3932 ****
  	
  	printf("Submit DDL Event to subscribers...\n");
  
! 	slon_mkquery(&query, "select \"_%s\".ddlScript_complete(%d, $1::text, %d); ", 
  		     stmt->hdr.script->clustername,
  		     stmt->ddl_setid,  
! 		     stmt->only_on_node);
  
  	paramlens[PARMCOUNT-1] = 0;
  	paramfmts[PARMCOUNT-1] = 0;
--- 3987,3997 ----
  	
  	printf("Submit DDL Event to subscribers...\n");
  
! 	slon_mkquery(&query, "select \"_%s\".ddlScript_complete(%d, $1::text, %d,%s); ", 
  		     stmt->hdr.script->clustername,
  		     stmt->ddl_setid,  
! 		     stmt->only_on_node,
! 			 dstring_data(&lock_tab_ids));
  
  	paramlens[PARMCOUNT-1] = 0;
  	paramfmts[PARMCOUNT-1] = 0;
***************
*** 3950,3955 ****
--- 4015,4021 ----
  	
  	dstring_free(&script);
  	dstring_free(&query);
+ 	dstring_free(&lock_tab_ids);
  	return 0;
  }
  
Index: src/slonik/slonik.h
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/src/slonik/slonik.h,v
retrieving revision 1.29
diff -c -r1.29 slonik.h
*** src/slonik/slonik.h	31 Oct 2006 22:09:40 -0000	1.29
--- src/slonik/slonik.h	18 Dec 2006 04:28:00 -0000
***************
*** 408,413 ****
--- 408,414 ----
  	int			ev_origin;
  	int			only_on_node;
  	FILE	   *ddl_fd;
+ 	char    ** table_locks;
  };
  
  
Index: tests/testddl/exec_ddl.sh
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/tests/testddl/exec_ddl.sh,v
retrieving revision 1.2
diff -c -r1.2 exec_ddl.sh
*** tests/testddl/exec_ddl.sh	29 Mar 2006 17:10:31 -0000	1.2
--- tests/testddl/exec_ddl.sh	18 Dec 2006 04:28:00 -0000
***************
*** 5,8 ****
--- 5,16 ----
         FILENAME = '${testname}/ddl_updates.sql',
         EVENT NODE = 1
      );
+ 
+   EXECUTE SCRIPT (
+       SET ID=1,
+       FILENAME = '${testname}/ddl_updates_tbl_locks.sql',
+       EVENT NODE=1,
+       LOCK TABLES=('public.table5','public.table1')
+ 
+    );
  "
Index: tests/testddl/init_add_tables.ik
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/tests/testddl/init_add_tables.ik,v
retrieving revision 1.2
diff -c -r1.2 init_add_tables.ik
*** tests/testddl/init_add_tables.ik	9 Jan 2006 20:12:56 -0000	1.2
--- tests/testddl/init_add_tables.ik	18 Dec 2006 04:28:00 -0000
***************
*** 4,6 ****
--- 4,7 ----
  set add table (id=3, set id=1, origin=1, fully qualified name = 'public.table3', key = SERIAL);
  set add table (id=4, set id=1, origin=1, fully qualified name = 'public.table4');
  set add table (id=5, set id=1, origin=1, fully qualified name = 'public.billing_discount');
+ set add table (id=6, set id=1, origin=1, fully qualified name='public.table5');
\ No newline at end of file
Index: tests/testddl/init_schema.sql
===================================================================
RCS file: /usr/local/cvsroot/slony1/slony1-engine/tests/testddl/init_schema.sql,v
retrieving revision 1.2
diff -c -r1.2 init_schema.sql
*** tests/testddl/init_schema.sql	9 Jan 2006 20:12:56 -0000	1.2
--- tests/testddl/init_schema.sql	18 Dec 2006 04:28:00 -0000
***************
*** 26,31 ****
--- 26,32 ----
    primary key (id1, id2)
  );
  
+ 
  insert into table4 (data) values ('BA Baracus');
  insert into table4 (data) values ('HM Murdoch');
  insert into table4 (data) values ('Face');
***************
*** 48,50 ****
--- 49,61 ----
  
  ALTER TABLE ONLY billing_discount
      ADD CONSTRAINT billing_discount_pkey PRIMARY KEY (billing_discount_id);
+ 
+ CREATE TABLE table5 (
+ 
+ 	id serial4
+ 	,a int4
+ 	,PRIMARY KEY(id)
+ );
+ 
+ INSERT INTO table5(a) VALUES (1);
+ INSERT INTO table5(b) VALUES (2);
From ssinger_pg at sympatico.ca  Sat Mar 17 10:06:54 2007
From: ssinger_pg at sympatico.ca (Steve Singer)
Date: Mon Mar 19 11:37:51 2007
Subject: [Slony1-patches] Re: [Slony1-general] Execute script and "execute
	only on"
In-Reply-To: <Pine.LNX.4.62.0703170838470.3246@mini.atlantida.localdomain>
References: <45FBB4B9.30501@haisuli.net>
	<Pine.LNX.4.62.0703170838470.3246@mini.atlantida.localdomain>
Message-ID: <Pine.LNX.4.62.0703171232030.3246@mini.atlantida.localdomain>

On Sat, 17 Mar 2007, Steve Singer wrote:

The attached patch against 1.2 should fix this bug by not
executing your DDL on the event node.

If your DDL has errors then you won't find out about it 
until slon tries to execute it on the other node (slonik won't give you an 
error but making changes just on your subscribers can have the potential 
for all sorts of trouble if your not careful)



> On Sat, 17 Mar 2007, Mikko Partio wrote:
>
> Your getting this because your EVENT_NODE is 1 but you only want to execute 
> the script on 2.
>
> Slonik probably should have a check to see if you have specified an only 
> excecute different than your event node and just submit the script into the 
> queue at that stage.
>
> Another option is to require the event node be equal to the only execute 
> node.
>
>
>
>> Hi,
>> 
>> slonik's EXECUTE SCRIPT -documentation says that:
>> 
>> EXECUTE ONLY ON = ival
>> 
>>   (Optional) The ID of the only node to actually execute the script.
>>   This option causes the script to be propagated by all nodes but
>>   executed only by one. The default is to execute the script on all
>>   nodes that are subscribed to the set.
>> 
>> 
>> In my experience this property is not working correctly, and here's the 
>> proof ("tiuhti" is origin and "viuhti" subscriber):
>> 
>> slony1@tiuhti:~$ psql -d cldb -c "CREATE TABLE testtable (id int)" -h 
>> tiuhti
>> CREATE TABLE
>> slony1@tiuhti:~$ psql -d cldb -c "CREATE TABLE testtable (id int)" -h 
>> viuhti
>> CREATE TABLE
>> 
>> slony1@tiuhti:~$ cat drop_table_testtable.sql
>> DROP TABLE testtable;
>> 
>> slony1@tiuhti:~$ cat droptest.slonik
>> #!/usr/bin/slonik
>> 
>> CLUSTER NAME=climate;
>> 
>> NODE 1 ADMIN CONNINFO = 'dbname=cldb host=tiuhti user=slony1';
>> NODE 2 ADMIN CONNINFO = 'dbname=cldb host=viuhti user=slony1';
>> 
>> EXECUTE SCRIPT (
>>       SET ID = 1,
>>       FILENAME = '/home/slony1/drop_table_testtable.sql',
>>       EVENT NODE = 1,
>>       EXECUTE ONLY ON = 2
>> );
>> 
>> slony1@tiuhti:~$ slonik droptest.slonik
>> DDL script consisting of 1 SQL statements
>> DDL Statement 0: (0,21) [DROP TABLE testtable;]
>> Submit DDL Event to subscribers...
>> DDL on origin - PGRES_TUPLES_OK
>> 
>> slony1@tiuhti:~$ psql -d cldb -c "\d testtable" -h viuhti
>> Did not find any relation named "testtable".
>> 
>> This is what I expected, but
>> 
>> slony1@tiuhti:~$ psql -d cldb -c "\d testtable" -h tiuhti
>> Did not find any relation named "testtable".
>> 
>> Wooah - the script dropped table testtable from both nodes although I 
>> specified the "execute only on" -option. Is there something I'm missing or 
>> is there a bug?
>> 
>> Regards
>> 
>> MP
>> 
>> _______________________________________________
>> Slony1-general mailing list
>> Slony1-general@lists.slony.info
>> http://lists.slony.info/mailman/listinfo/slony1-general
>> 
>
> _______________________________________________
> Slony1-general mailing list
> Slony1-general@lists.slony.info
> http://lists.slony.info/mailman/listinfo/slony1-general
>
-------------- next part --------------
Index: slonik/slonik.c
===================================================================
RCS file: /slony1/slony1-engine/src/slonik/slonik.c,v
retrieving revision 1.67.2.6
diff -c -w -r1.67.2.6 slonik.c
*** slonik/slonik.c	15 Mar 2007 18:52:02 -0000	1.67.2.6
--- slonik/slonik.c	17 Mar 2007 16:30:55 -0000
***************
*** 3916,3921 ****
--- 3916,3926 ----
  		}
  		strncpy(dest, dstring_data(&script) + startpos, endpos-startpos);
  		dest[STMTS[stmtno]-startpos] = 0;
+ 
+ 		if(stmt->only_on_node==-1 ||
+ 		   stmt->only_on_node ==stmt->ev_origin) 
+ 		  {
+ 
  		  slon_mkquery(&query, dest);
  		  printf("DDL Statement %d: (%d,%d) [%s]\n", stmtno, startpos, endpos, dest);
  		  free(dest);
***************
*** 3933,3938 ****
--- 3938,3955 ----
  		    }
  		  /* rstat = PQresultStatus(res); */
  		  /* printf ("Success - %s\n", PQresStatus(rstat)); */
+ 
+ 		  }
+ 		else {
+ 
+ 		    /**
+ 		     * Do not execute
+ 		     */
+ 		    printf("Skipping EXECUTE SCRIPT on node %d only for %d\n",
+ 			   stmt->only_on_node, stmt->ev_origin);
+ 		}
+ 
+ 
  	}
  	
  	printf("Submit DDL Event to subscribers...\n");
From dun at haisuli.net  Sat Mar 17 10:11:16 2007
From: dun at haisuli.net (Mikko Partio)
Date: Mon Mar 19 11:37:51 2007
Subject: [Slony1-patches] Re: [Slony1-general] Execute script and "execute
	only on"
In-Reply-To: <Pine.LNX.4.62.0703171232030.3246@mini.atlantida.localdomain>
References: <45FBB4B9.30501@haisuli.net>
	<Pine.LNX.4.62.0703170838470.3246@mini.atlantida.localdomain>
	<Pine.LNX.4.62.0703171232030.3246@mini.atlantida.localdomain>
Message-ID: <45FC2134.80601@haisuli.net>

Steve Singer wrote:
> On Sat, 17 Mar 2007, Steve Singer wrote:
>
> The attached patch against 1.2 should fix this bug by not
> executing your DDL on the event node.
>
> If your DDL has errors then you won't find out about it until slon 
> tries to execute it on the other node (slonik won't give you an error 
> but making changes just on your subscribers can have the potential for 
> all sorts of trouble if your not careful)
>
Thanks for your quick response. I will try out this patch asap.

Regards

MP
From ssinger_pg at sympatico.ca  Sat Mar 24 15:31:51 2007
From: ssinger_pg at sympatico.ca (Steve Singer)
Date: Sat Mar 24 15:32:07 2007
Subject: [Slony1-patches] Re: [Slony1-general] Execute script and "execute
	only on"
In-Reply-To: <Pine.LNX.4.62.0703171232030.3246@mini.atlantida.localdomain>
References: <45FBB4B9.30501@haisuli.net>
	<Pine.LNX.4.62.0703170838470.3246@mini.atlantida.localdomain>
	<Pine.LNX.4.62.0703171232030.3246@mini.atlantida.localdomain>
Message-ID: <Pine.LNX.4.62.0703241820090.2846@mini.atlantida.localdomain>

On Sat, 17 Mar 2007, Steve Singer wrote:

The attached patch replaces the one I sent last week.  This version has the 
only_on execute script executed directly against the subscriber node by 
slonik as discussed on slony1-general.

Also per the discussion on general this patch also includes a fix so that 
subscribers that do not subscribe to the set a script is submitted against 
do not receive the script (As was the behaviour in the 1.1 series)

These patches are all against the 1.2 branch.


Steve

> On Sat, 17 Mar 2007, Steve Singer wrote:
>
> The attached patch against 1.2 should fix this bug by not
> executing your DDL on the event node.
>
> If your DDL has errors then you won't find out about it until slon tries to 
> execute it on the other node (slonik won't give you an error but making 
> changes just on your subscribers can have the potential for all sorts of 
> trouble if your not careful)
>
>
>
>> On Sat, 17 Mar 2007, Mikko Partio wrote:
>> 
>> Your getting this because your EVENT_NODE is 1 but you only want to execute 
>> the script on 2.
>> 
>> Slonik probably should have a check to see if you have specified an only 
>> excecute different than your event node and just submit the script into the 
>> queue at that stage.
>> 
>> Another option is to require the event node be equal to the only execute 
>> node.
>> 
>> 
>> 
>>> Hi,
>>> 
>>> slonik's EXECUTE SCRIPT -documentation says that:
>>> 
>>> EXECUTE ONLY ON = ival
>>> 
>>>   (Optional) The ID of the only node to actually execute the script.
>>>   This option causes the script to be propagated by all nodes but
>>>   executed only by one. The default is to execute the script on all
>>>   nodes that are subscribed to the set.
>>> 
>>> 
>>> In my experience this property is not working correctly, and here's the 
>>> proof ("tiuhti" is origin and "viuhti" subscriber):
>>> 
>>> slony1@tiuhti:~$ psql -d cldb -c "CREATE TABLE testtable (id int)" -h 
>>> tiuhti
>>> CREATE TABLE
>>> slony1@tiuhti:~$ psql -d cldb -c "CREATE TABLE testtable (id int)" -h 
>>> viuhti
>>> CREATE TABLE
>>> 
>>> slony1@tiuhti:~$ cat drop_table_testtable.sql
>>> DROP TABLE testtable;
>>> 
>>> slony1@tiuhti:~$ cat droptest.slonik
>>> #!/usr/bin/slonik
>>> 
>>> CLUSTER NAME=climate;
>>> 
>>> NODE 1 ADMIN CONNINFO = 'dbname=cldb host=tiuhti user=slony1';
>>> NODE 2 ADMIN CONNINFO = 'dbname=cldb host=viuhti user=slony1';
>>> 
>>> EXECUTE SCRIPT (
>>>       SET ID = 1,
>>>       FILENAME = '/home/slony1/drop_table_testtable.sql',
>>>       EVENT NODE = 1,
>>>       EXECUTE ONLY ON = 2
>>> );
>>> 
>>> slony1@tiuhti:~$ slonik droptest.slonik
>>> DDL script consisting of 1 SQL statements
>>> DDL Statement 0: (0,21) [DROP TABLE testtable;]
>>> Submit DDL Event to subscribers...
>>> DDL on origin - PGRES_TUPLES_OK
>>> 
>>> slony1@tiuhti:~$ psql -d cldb -c "\d testtable" -h viuhti
>>> Did not find any relation named "testtable".
>>> 
>>> This is what I expected, but
>>> 
>>> slony1@tiuhti:~$ psql -d cldb -c "\d testtable" -h tiuhti
>>> Did not find any relation named "testtable".
>>> 
>>> Wooah - the script dropped table testtable from both nodes although I 
>>> specified the "execute only on" -option. Is there something I'm missing or 
>>> is there a bug?
>>> 
>>> Regards
>>> 
>>> MP
>>> 
>>> _______________________________________________
>>> Slony1-general mailing list
>>> Slony1-general@lists.slony.info
>>> http://lists.slony.info/mailman/listinfo/slony1-general
>>> 
>> 
>> _______________________________________________
>> Slony1-general mailing list
>> Slony1-general@lists.slony.info
>> http://lists.slony.info/mailman/listinfo/slony1-general
>> 
>
-------------- next part --------------
Index: src/backend/slony1_funcs.sql
===================================================================
RCS file: /slony1/slony1-engine/src/backend/slony1_funcs.sql,v
retrieving revision 1.98.2.13
diff -c -r1.98.2.13 slony1_funcs.sql
*** src/backend/slony1_funcs.sql	22 Mar 2007 20:41:27 -0000	1.98.2.13
--- src/backend/slony1_funcs.sql	24 Mar 2007 22:24:19 -0000
***************
*** 3683,3690 ****
--- 3683,3693 ----
  	-- ----
  	lock table @NAMESPACE@.sl_config_lock;
  
+ 	
  	-- ----
  	-- Check that the set exists and originates here
+ 	-- unless only_on_node was specified (then it can be applied to
+ 	-- that node because that is what the user wanted)
  	-- ----
  	select set_origin into v_set_origin
  			from @NAMESPACE@.sl_set
***************
*** 3693,3699 ****
  	if not found then
  		raise exception ''Slony-I: set % not found'', p_set_id;
  	end if;
! 	if v_set_origin <> @NAMESPACE@.getLocalNodeId(''_@CLUSTERNAME@'') then
  		raise exception ''Slony-I: set % does not originate on local node'',
  				p_set_id;
  	end if;
--- 3696,3703 ----
  	if not found then
  		raise exception ''Slony-I: set % not found'', p_set_id;
  	end if;
! 	if v_set_origin <> @NAMESPACE@.getLocalNodeId(''_@CLUSTERNAME@'') AND
! 	p_only_on_node=-1 then
  		raise exception ''Slony-I: set % does not originate on local node'',
  				p_set_id;
  	end if;
***************
*** 5904,5907 ****
  to specify fields for the passed-in tab_id.  
  
  In PG versions > 7.3, this looks like (field1,field2,...fieldn)';
- 
--- 5908,5910 ----
Index: src/slon/remote_worker.c
===================================================================
RCS file: /slony1/slony1-engine/src/slon/remote_worker.c,v
retrieving revision 1.124.2.12
diff -c -r1.124.2.12 remote_worker.c
*** src/slon/remote_worker.c	6 Mar 2007 18:47:45 -0000	1.124.2.12
--- src/slon/remote_worker.c	24 Mar 2007 22:24:22 -0000
***************
*** 268,273 ****
--- 268,276 ----
  
  static void compress_actionseq(const char *ssy_actionseq, SlonDString * action_subquery);
  
+ static int process_ddl_script(SlonWorkMsg_event * event,SlonNode * node,
+ 							  PGconn * local_dbconn, char * seqbuf );
+ static int check_set_subscriber(int set_id, int node_id,PGconn * local_dbconn);
  
  /* ----------
   * slon_remoteWorkerThread
***************
*** 1339,1439 ****
  			}
  			else if (strcmp(event->ev_type, "DDL_SCRIPT") == 0)
  			{
! 				int			ddl_setid = (int)strtol(event->ev_data1, NULL, 10);
! 				char	   *ddl_script = event->ev_data2;
! 				int			ddl_only_on_node = (int)strtol(event->ev_data3, NULL, 10);
! 				int num_statements = -1, stmtno;
! 
! 				PGresult *res;
! 				ExecStatusType rstat;
! 
! 
! 				slon_appendquery(&query1,
! 						 "select %s.ddlScript_prepare_int(%d, %d); ",
! 						 rtcfg_namespace,
! 						 ddl_setid, ddl_only_on_node);
! 
! 				if (query_execute(node, local_dbconn, &query1) < 0) {
! 						slon_log(SLON_ERROR, "remoteWorkerThread_%d: DDL preparation failed - set %d - only on node %\n",
! 							 node->no_id, ddl_setid, ddl_only_on_node);
! 						slon_retry();
! 				}
! 
! 				num_statements = scan_for_statements (ddl_script);
! 				slon_log(SLON_CONFIG, "remoteWorkerThread_%d: DDL request with %d statements\n",
! 					 node->no_id, num_statements);
! 				if ((num_statements < 0) || (num_statements >= MAXSTATEMENTS)) {
! 					slon_log(SLON_ERROR, "remoteWorkerThread_%d: DDL had invalid number of statements - %d\n", 
! 						 node->no_id, num_statements);
! 					slon_retry();
! 				}
! 				
! 				for (stmtno=0; stmtno < num_statements;  stmtno++) {
! 					int startpos, endpos;
! 					char *dest;
! 					if (stmtno == 0)
! 						startpos = 0;
! 					else
! 						startpos = STMTS[stmtno-1];
! 
! 					endpos = STMTS[stmtno];
! 					dest = (char *) malloc (endpos - startpos + 1);
! 					if (dest == 0) {
! 						slon_log(SLON_ERROR, "remoteWorkerThread_%d: malloc() failure in DDL_SCRIPT - could not allocate %d bytes of memory\n", 
! 							 node->no_id, endpos - startpos + 1);
! 						slon_retry();
! 					}
! 					strncpy(dest, ddl_script + startpos, endpos-startpos);
! 					dest[STMTS[stmtno]-startpos] = 0;
! 					slon_mkquery(&query1, dest);
! 					slon_log(SLON_CONFIG, "remoteWorkerThread_%d: DDL Statement %d: [%s]\n", 
! 						 node->no_id, stmtno, dest);						 
! 					free(dest);
! 
! 					res = PQexec(local_dbconn, dstring_data(&query1));
! 
! 					if (PQresultStatus(res) != PGRES_COMMAND_OK && 
! 					    PQresultStatus(res) != PGRES_TUPLES_OK &&
! 					    PQresultStatus(res) != PGRES_EMPTY_QUERY)
! 					{
! 						rstat = PQresultStatus(res);
! 						slon_log(SLON_ERROR, "DDL Statement failed - %s\n", PQresStatus(rstat));
! 						dstring_free(&query1);
! 						slon_retry();
! 					}
! 					rstat = PQresultStatus(res);
! 					slon_log (SLON_CONFIG, "DDL success - %s\n", PQresStatus(rstat));
! 				}
! 	
! 				slon_mkquery(&query1, "select %s.ddlScript_complete_int(%d, %d); ", 
! 					     rtcfg_namespace,
! 					     ddl_setid,
! 					     ddl_only_on_node);
! 
! 				/* DDL_SCRIPT needs to be turned into a log shipping script */
! 				/* Note that the issue about parsing that mandates breaking 
! 				   up compound statements into
! 				   individually-processed statements does not apply to log
! 				   shipping as psql parses and processes each statement
! 				   individually */
! 
! 				if (archive_dir)
! 				{
! 					if ((ddl_only_on_node < 1) || (ddl_only_on_node == rtcfg_nodeid))
! 					{
! 
! 						if (archive_open(node, seqbuf) < 0)
! 							slon_retry();
! 						if (archive_tracking(node, rtcfg_namespace, 
! 								ddl_setid, seqbuf, seqbuf, 
! 								event->ev_timestamp_c) < 0)
! 							slon_retry();
! 						if (archive_append_str(node, ddl_script) < 0)
! 							slon_retry();
! 						if (archive_close(node) < 0)
! 							slon_retry();
! 					}
! 				}
  			}
  			else if (strcmp(event->ev_type, "RESET_CONFIG") == 0)
  			{
--- 1342,1348 ----
  			}
  			else if (strcmp(event->ev_type, "DDL_SCRIPT") == 0)
  			{
! 				process_ddl_script(event,node,local_dbconn,seqbuf);
  			}
  			else if (strcmp(event->ev_type, "RESET_CONFIG") == 0)
  			{
***************
*** 6097,6099 ****
--- 6006,6175 ----
  	}
  	slon_log(SLON_DEBUG4, " compressed actionseq subquery... %s\n", dstring_data(action_subquery));
  }
+ 
+ 
+ /**
+  *
+  * Process a ddl_script command.
+  */
+ static int process_ddl_script(SlonWorkMsg_event * event,SlonNode * node,
+ 							  PGconn * local_dbconn,
+ 							  char * seqbuf) 
+ {
+ 	int			ddl_setid = (int)strtol(event->ev_data1, NULL, 10);
+ 	char	   *ddl_script = event->ev_data2;
+ 	int			ddl_only_on_node = (int)strtol(event->ev_data3, NULL, 10);
+ 	int num_statements = -1, stmtno;
+ 	int node_in_set;
+ 	int localNodeId;
+ 	PGresult *res;
+ 	ExecStatusType rstat;
+ 	SlonDString query1;
+ 
+ 	
+ 
+ 	dstring_init(&query1);
+ 	/**
+ 	 * Check to make sure this node is part of the set
+ 	 */
+ 	slon_log(SLON_INFO, "Checking local node id");
+ 	localNodeId = db_getLocalNodeId(local_dbconn);
+ 	slon_log(SLON_INFO,"Found local node id");
+ 	node_in_set = check_set_subscriber(ddl_setid,localNodeId,local_dbconn);
+ 	
+ 	if(!node_in_set) {
+ 		/**
+ 		 *
+ 		 * Node is not part of the set.  
+ 		 * Do not forward teh DDL to the node,
+ 		 * nor should it be included in the log for log-shipping.
+ 		 */
+ 		slon_log(SLON_INFO,"Not forwarding DDL to node %d for set %d\n",
+ 				 node->no_id,ddl_setid);
+ 		
+ 	}
+ 	else 
+ 	{
+ 		slon_appendquery(&query1,
+ 						 "select %s.ddlScript_prepare_int(%d, %d); ",
+ 						 rtcfg_namespace,
+ 						 ddl_setid, ddl_only_on_node);
+ 		
+ 		if (query_execute(node, local_dbconn, &query1) < 0) {
+ 			slon_log(SLON_ERROR, "remoteWorkerThread_%d: DDL preparation failed - set %d - only on node %\n",
+ 					 node->no_id, ddl_setid, ddl_only_on_node);			
+ 			slon_retry();
+ 		}
+ 		
+ 		num_statements = scan_for_statements (ddl_script);
+ 		slon_log(SLON_CONFIG, "remoteWorkerThread_%d: DDL request with %d statements\n",
+ 				 node->no_id, num_statements);
+ 		if ((num_statements < 0) || (num_statements >= MAXSTATEMENTS)) {
+ 			slon_log(SLON_ERROR, "remoteWorkerThread_%d: DDL had invalid number of statements - %d\n", 
+ 					 node->no_id, num_statements);
+ 			slon_retry();
+ 		}
+ 		
+ 		for (stmtno=0; stmtno < num_statements;  stmtno++) {
+ 			int startpos, endpos;
+ 			char *dest;
+ 			if (stmtno == 0)
+ 				startpos = 0;
+ 			else
+ 				startpos = STMTS[stmtno-1];
+ 			
+ 			endpos = STMTS[stmtno];
+ 			dest = (char *) malloc (endpos - startpos + 1);
+ 			if (dest == 0) {
+ 				slon_log(SLON_ERROR, "remoteWorkerThread_%d: malloc() failure in DDL_SCRIPT - could not allocate %d bytes of memory\n", 
+ 						 node->no_id, endpos - startpos + 1);
+ 				slon_retry();
+ 			}
+ 			strncpy(dest, ddl_script + startpos, endpos-startpos);
+ 			dest[STMTS[stmtno]-startpos] = 0;
+ 			slon_mkquery(&query1, dest);
+ 			slon_log(SLON_CONFIG, "remoteWorkerThread_%d: DDL Statement %d: [%s]\n", 
+ 					 node->no_id, stmtno, dest);						 
+ 			free(dest);
+ 			
+ 			res = PQexec(local_dbconn, dstring_data(&query1));
+ 			
+ 			if (PQresultStatus(res) != PGRES_COMMAND_OK && 
+ 				PQresultStatus(res) != PGRES_TUPLES_OK &&
+ 				PQresultStatus(res) != PGRES_EMPTY_QUERY)
+ 				{
+ 					rstat = PQresultStatus(res);
+ 					slon_log(SLON_ERROR, "DDL Statement failed - %s\n", PQresStatus(rstat));
+ 					dstring_free(&query1);
+ 					slon_retry();
+ 				}
+ 			rstat = PQresultStatus(res);
+ 			slon_log (SLON_CONFIG, "DDL success - %s\n", PQresStatus(rstat));
+ 		}
+ 		
+ 		slon_mkquery(&query1, "select %s.ddlScript_complete_int(%d, %d); ", 
+ 					 rtcfg_namespace,
+ 					 ddl_setid,
+ 					 ddl_only_on_node);
+ 		
+ 		/* DDL_SCRIPT needs to be turned into a log shipping script */
+ 		/* Note that the issue about parsing that mandates breaking 
+ 		   up compound statements into
+ 		   individually-processed statements does not apply to log
+ 		   shipping as psql parses and processes each statement
+ 		   individually */
+ 		
+ 		if (archive_dir)
+ 			{
+ 				if ((ddl_only_on_node < 1) || (ddl_only_on_node == rtcfg_nodeid))
+ 					{
+ 						
+ 						if (archive_open(node, seqbuf) < 0)
+ 							slon_retry();
+ 						if (archive_tracking(node, rtcfg_namespace, 
+ 											 ddl_setid, seqbuf, seqbuf, 
+ 											 event->ev_timestamp_c) < 0)
+ 							slon_retry();
+ 						if (archive_append_str(node, ddl_script) < 0)
+ 							slon_retry();
+ 						if (archive_close(node) < 0)
+ 							slon_retry();
+ 					}
+ 			}
+ 	}/*else node a subscriber */
+ 	
+ 	dstring_free(&query1);
+ 
+ }
+ 
+ /**
+  * Checks to see if the node specified is a member of the set.
+  *
+  */
+ static int check_set_subscriber(int set_id, int node_id,PGconn * local_dbconn) 
+ {
+   
+   
+   SlonDString query1;
+   PGresult* res;
+   dstring_init(&query1);
+ 
+   slon_appendquery(&query1,"select 1 from %s.sl_subscribe WHERE sub_set=%d AND sub_receiver=%d for update"
+ 	       ,rtcfg_namespace,set_id,node_id);
+   res = PQexec(local_dbconn,dstring_data(&query1));
+   if(PQresultStatus(res)!=PGRES_TUPLES_OK) {
+     slon_log(SLON_ERROR,"remoteWorkerThread_%d: DDL preperation can not check set membership"
+ 	     ,node_id);
+ 	dstring_free(&query1);
+     slon_retry();
+   }
+   dstring_free(&query1);
+   if(PQntuples(res)==0) {
+     PQclear(res);
+     return 0;
+   }
+   PQclear(res);
+   return 1;
+ 
+ 
+ }
Index: src/slonik/slonik.c
===================================================================
RCS file: /slony1/slony1-engine/src/slonik/slonik.c,v
retrieving revision 1.67.2.6
diff -c -r1.67.2.6 slonik.c
*** src/slonik/slonik.c	15 Mar 2007 18:52:02 -0000	1.67.2.6
--- src/slonik/slonik.c	24 Mar 2007 22:24:24 -0000
***************
*** 3849,3861 ****
  	PGresult *res;
  	ExecStatusType rstat;
  
  #define PARMCOUNT 1  
  
          const char *params[PARMCOUNT];
          int paramlens[PARMCOUNT];
          int paramfmts[PARMCOUNT];
  
! 	adminfo1 = get_active_adminfo((SlonikStmt *) stmt, stmt->ev_origin);
  	if (adminfo1 == NULL)
  		return -1;
  
--- 3849,3865 ----
  	PGresult *res;
  	ExecStatusType rstat;
  
+ 
  #define PARMCOUNT 1  
  
          const char *params[PARMCOUNT];
          int paramlens[PARMCOUNT];
          int paramfmts[PARMCOUNT];
  
! 	if(stmt->only_on_node>-1) {
! 		adminfo1 = get_active_adminfo((SlonikStmt*) stmt,stmt->only_on_node);
! 	}
! 	  adminfo1 = get_active_adminfo((SlonikStmt *) stmt, stmt->ev_origin);
  	if (adminfo1 == NULL)
  		return -1;
  
***************
*** 3935,3967 ****
  		/* printf ("Success - %s\n", PQresStatus(rstat)); */
  	}
  	
! 	printf("Submit DDL Event to subscribers...\n");
! 
! 	slon_mkquery(&query, "select \"_%s\".ddlScript_complete(%d, $1::text, %d); ", 
! 		     stmt->hdr.script->clustername,
! 		     stmt->ddl_setid,  
! 		     stmt->only_on_node);
! 
! 	paramlens[PARMCOUNT-1] = 0;
! 	paramfmts[PARMCOUNT-1] = 0;
! 	params[PARMCOUNT-1] = dstring_data(&script);
! 
! 	res = PQexecParams(adminfo1->dbconn, dstring_data(&query), PARMCOUNT,
! 			   NULL, params, paramlens, paramfmts, 0);
! 	
! 	if (PQresultStatus(res) != PGRES_COMMAND_OK && 
! 	    PQresultStatus(res) != PGRES_TUPLES_OK &&
! 	    PQresultStatus(res) != PGRES_EMPTY_QUERY)
! 	{
! 		rstat = PQresultStatus(res);
! 		printf("Event submission for DDL failed - %s\n", PQresStatus(rstat));
! 		dstring_free(&query);
! 		return -1;
! 	} else {
! 		rstat = PQresultStatus(res);
! 		printf ("DDL on origin - %s\n", PQresStatus(rstat));
! 	}
! 	
  	dstring_free(&script);
  	dstring_free(&query);
  	return 0;
--- 3939,3972 ----
  		/* printf ("Success - %s\n", PQresStatus(rstat)); */
  	}
  	
! 	if(stmt->only_on_node==-1) {
! 		printf("Submit DDL Event to subscribers...\n");
! 		
! 		slon_mkquery(&query, "select \"_%s\".ddlScript_complete(%d, $1::text, %d); ", 
! 					 stmt->hdr.script->clustername,
! 					 stmt->ddl_setid,  
! 					 stmt->only_on_node);
! 		
! 		paramlens[PARMCOUNT-1] = 0;
! 		paramfmts[PARMCOUNT-1] = 0;
! 		params[PARMCOUNT-1] = dstring_data(&script);
! 		
! 		res = PQexecParams(adminfo1->dbconn, dstring_data(&query), PARMCOUNT,
! 						   NULL, params, paramlens, paramfmts, 0);
! 		
! 		if (PQresultStatus(res) != PGRES_COMMAND_OK && 
! 			PQresultStatus(res) != PGRES_TUPLES_OK &&
! 			PQresultStatus(res) != PGRES_EMPTY_QUERY)
! 			{
! 				rstat = PQresultStatus(res);
! 				printf("Event submission for DDL failed - %s\n", PQresStatus(rstat));
! 				dstring_free(&query);
! 				return -1;
! 			} else {
! 				rstat = PQresultStatus(res);
! 				printf ("DDL on origin - %s\n", PQresStatus(rstat));
! 			}
! 	}/*only on node*/
  	dstring_free(&script);
  	dstring_free(&query);
  	return 0;
From ahodgson at simkin.ca  Thu Mar 29 13:20:28 2007
From: ahodgson at simkin.ca (Alan Hodgson)
Date: Thu Mar 29 13:20:37 2007
Subject: [Slony1-patches] Re: [Slony1-general] Problem with 1.2.8 and
	EXECUTE SCRIPT with multiple sets
In-Reply-To: <Pine.LNX.4.62.0703272037290.2859@mini.atlantida.localdomain>
References: <200703270949.43495@hal.medialogik.com>
	<Pine.LNX.4.62.0703272037290.2859@mini.atlantida.localdomain>
Message-ID: <200703291320.28223@hal.medialogik.com>

On Tuesday 27 March 2007 17:45, Steve Singer <ssinger_pg@sympatico.ca> =

wrote:
> On Tue, 27 Mar 2007, Alan Hodgson wrote:
>
> I don't know what workarounds are going to be options for you compared
> with running a patched version of slony but if you
> need a fix right away you could consider patching your version of slony.
>
> The patched attached to
> http://lists.slony.info/pipermail/slony1-patches/2007-March/000005.html
>

This patch is incomplete in one respect that I have found; it doesn't =

actually execute ddlScript_complete_int after preparing the query.  The =

attached replaces it.


-- =

Ginsberg's Theorem:
 1) You can't win.
 2) You can't break even.
 3) You can't quit the game.

-------------- next part --------------
A non-text attachment was scrubbed...
Name: slony-ddl-correct-nodes.patch
Type: text/x-diff
Size: 13473 bytes
Desc: not available
Url : http://lists.slony.info/pipermail/slony1-patches/attachments/20070329=
/b4f90fd3/slony-ddl-correct-nodes.bin
From cbbrowne at ca.afilias.info  Thu Mar 29 15:50:56 2007
From: cbbrowne at ca.afilias.info (Christopher Browne)
Date: Thu Mar 29 15:51:05 2007
Subject: [Slony1-patches] Re: [Slony1-general] Problem with 1.2.8 and
	EXECUTE SCRIPT with multiple sets
In-Reply-To: <200703291320.28223@hal.medialogik.com>
References: <200703270949.43495@hal.medialogik.com>	<Pine.LNX.4.62.0703272037290.2859@mini.atlantida.localdomain>
	<200703291320.28223@hal.medialogik.com>
Message-ID: <460C42D0.1080402@ca.afilias.info>

Alan Hodgson wrote:
> On Tuesday 27 March 2007 17:45, Steve Singer <ssinger_pg@sympatico.ca> 
> wrote:
>   
>> On Tue, 27 Mar 2007, Alan Hodgson wrote:
>>
>> I don't know what workarounds are going to be options for you compared
>> with running a patched version of slony but if you
>> need a fix right away you could consider patching your version of slony.
>>
>> The patched attached to
>> http://lists.slony.info/pipermail/slony1-patches/2007-March/000005.html
>>
>>     
>
> This patch is incomplete in one respect that I have found; it doesn't 
> actually execute ddlScript_complete_int after preparing the query.  The 
> attached replaces it.
>   
I've applied this to my copy of 1.2; will see if I can do some testing
tomorrow.

I'd like to construct a test case that visibly breaks without the
change, and which works with it; if you can outline a quick example,
that would be helpful to the testing process...

